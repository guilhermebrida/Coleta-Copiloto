{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Coleta GFx Copiloto Documenta\u00e7\u00e3o para utiliza\u00e7\u00e3o do codigo em python para coleta das mensagens do buffer GF0 pela serial do copiloto Instalar as depend\u00eancias pip install -r requirements.txt Bibliotecas import serial - Comunica\u00e7\u00e3o serial import asyncio - Biblioteca ass\u00edncrona import XVM - Biblioteca para formata\u00e7\u00e3o do XVM (linguagem do copiloto) import serial.tools.list_ports - Listar as portas COM dispon\u00edveis import psycopg2 - Biblioteca para se conectar no banco postgres","title":"Coleta GFx Copiloto"},{"location":"#coleta-gfx-copiloto","text":"Documenta\u00e7\u00e3o para utiliza\u00e7\u00e3o do codigo em python para coleta das mensagens do buffer GF0 pela serial do copiloto","title":"Coleta GFx Copiloto"},{"location":"#instalar-as-dependencias","text":"pip install -r requirements.txt","title":"Instalar as depend\u00eancias"},{"location":"#bibliotecas","text":"import serial - Comunica\u00e7\u00e3o serial import asyncio - Biblioteca ass\u00edncrona import XVM - Biblioteca para formata\u00e7\u00e3o do XVM (linguagem do copiloto) import serial.tools.list_ports - Listar as portas COM dispon\u00edveis import psycopg2 - Biblioteca para se conectar no banco postgres","title":"Bibliotecas"},{"location":"XVM/","text":"XVM calcCheckSum Fun\u00e7\u00e3o respons\u00e1vel para calcular o checksum de cada mensagem no padr\u00e3o XVM Recebe: mensagem(str) def calcCheckSum (msg): num = msg.find(';*')+1 calc = 0 for i in range(num): calc ^= ord(msg[i]) return calc parseXVM Fun\u00e7\u00e3o respons\u00e1vel por separar todos os atributos contidos em uma mensagem XVM Recebe: mensagem(str) def parseXVM(msg): xvmMessage=msg.split(';') message = xvmMessage[0] id = xvmMessage[1][3:] sequence = int(xvmMessage[2][1:],16) checksum = int(xvmMessage[3][1:3],16) return (message,id,sequence,checksum) generateAck Fun\u00e7\u00e3o que gera o ACK do copiloto Recebe: id (str) e sequence (str) def generateAck(id,sequence): resp = '>ACK;ID='+id+';#'+format(sequence,'04X')+';*' resp = resp+format(calcCheckSum(resp),'02X')+'<\\r\\n' return resp generateXVM Fun\u00e7\u00e3o que gera uma mensagem XVM Recebe: id (str), sequence (str), message (str) def generateXVM(id,sequence,message): resp = message+';ID='+id+';#'+sequence+';*' resp = resp+format(calcCheckSum(resp),'02X')+'<\\r\\n' return resp isValidXVM Fun\u00e7\u00e3o valida se a mensagem recebida \u00e9 uma mensagem no padr\u00e3o XVM Recebe: id (str), sequence (str), message (str) def isValidXVM(msg): return 1 if calcCheckSum(msg)==parseXVM(msg)[3] else 0","title":"XVM"},{"location":"XVM/#xvm","text":"","title":"XVM"},{"location":"XVM/#calcchecksum","text":"Fun\u00e7\u00e3o respons\u00e1vel para calcular o checksum de cada mensagem no padr\u00e3o XVM Recebe: mensagem(str) def calcCheckSum (msg): num = msg.find(';*')+1 calc = 0 for i in range(num): calc ^= ord(msg[i]) return calc","title":"calcCheckSum"},{"location":"XVM/#parsexvm","text":"Fun\u00e7\u00e3o respons\u00e1vel por separar todos os atributos contidos em uma mensagem XVM Recebe: mensagem(str) def parseXVM(msg): xvmMessage=msg.split(';') message = xvmMessage[0] id = xvmMessage[1][3:] sequence = int(xvmMessage[2][1:],16) checksum = int(xvmMessage[3][1:3],16) return (message,id,sequence,checksum)","title":"parseXVM"},{"location":"XVM/#generateack","text":"Fun\u00e7\u00e3o que gera o ACK do copiloto Recebe: id (str) e sequence (str) def generateAck(id,sequence): resp = '>ACK;ID='+id+';#'+format(sequence,'04X')+';*' resp = resp+format(calcCheckSum(resp),'02X')+'<\\r\\n' return resp","title":"generateAck"},{"location":"XVM/#generatexvm","text":"Fun\u00e7\u00e3o que gera uma mensagem XVM Recebe: id (str), sequence (str), message (str) def generateXVM(id,sequence,message): resp = message+';ID='+id+';#'+sequence+';*' resp = resp+format(calcCheckSum(resp),'02X')+'<\\r\\n' return resp","title":"generateXVM"},{"location":"XVM/#isvalidxvm","text":"Fun\u00e7\u00e3o valida se a mensagem recebida \u00e9 uma mensagem no padr\u00e3o XVM Recebe: id (str), sequence (str), message (str) def isValidXVM(msg): return 1 if calcCheckSum(msg)==parseXVM(msg)[3] else 0","title":"isValidXVM"},{"location":"banco/","text":"Banco de Dados init.db Exemplo de tabela para a inser\u00e7\u00e3o dos dados, Colunas: device_id: o id do copiloto message: a mensagem coletada pela serial reception_datetime: data e hora da coleta da mensagem, timezone de S\u00e3o Paulo CREATE TABLE IF NOT EXISTS public.coleta ( device_id text COLLATE pg_catalog.\"default\" NOT NULL, message text COLLATE pg_catalog.\"default\", reception_datetime timestamp with time zone DEFAULT timezone('America/Sao_Paulo', now()) );","title":"Banco de Dados"},{"location":"banco/#banco-de-dados","text":"","title":"Banco de Dados"},{"location":"banco/#initdb","text":"Exemplo de tabela para a inser\u00e7\u00e3o dos dados, Colunas: device_id: o id do copiloto message: a mensagem coletada pela serial reception_datetime: data e hora da coleta da mensagem, timezone de S\u00e3o Paulo CREATE TABLE IF NOT EXISTS public.coleta ( device_id text COLLATE pg_catalog.\"default\" NOT NULL, message text COLLATE pg_catalog.\"default\", reception_datetime timestamp with time zone DEFAULT timezone('America/Sao_Paulo', now()) );","title":"init.db"},{"location":"coleta/","text":"Descarga GFx Arquivo coleta_GFx.py Conecta ao banco ENDPOINT=\"localhost\" PORT=\"5432\" USER=\"postgres\" DBNAME=\"inbox\" connection = psycopg2.connect(host=ENDPOINT, user=USER, password='postgres', port=PORT, database=DBNAME) cursor = connection.cursor() Estabelecer conex\u00e3o com o copiloto Fun\u00e7\u00e3o que estabelece uma conex\u00e3o serial com um dispositivo em uma porta COM e retorna seu ID. Envia QVR para a porta COM utilizando a fun\u00e7\u00e3o generateXVM que deixa o comando no formato em que o copiloto ir\u00e1 entender Argumentos: COM (str): A porta COM \u00e0 qual o dispositivo est\u00e1 conectado. Retorna: str: O ID do copiloto conectado. async def conexao(COM): s = serial.Serial(COM, 19200, timeout=10) id = '-' try: for i in range(5): xvm = XVM.generateXVM('1234',str(i).zfill(4),'>QVR<') print(xvm) s.write(xvm.encode()) resposta = s.readline().decode() id = resposta.split(';')[1][3::] if id != '1234': print(id) return id except Exception: print('PORTA SEM COMUNICA\u00c7\u00c3O') pass Comandos de configura\u00e7\u00e3o do copiloto Fun\u00e7\u00e3o que envia o comando >TCFG53,2< e >VSIP0,TRM1< para ativar a fun\u00e7\u00e3o de descarga do buffer GF0 pela serial \u00c9 necess\u00e1rio utilizar a fun\u00e7\u00e3o generateXVM para formatar os comandos no formato XVM Argumentos: COM (str): A porta COM \u00e0 qual o dispositivo est\u00e1 conectado. device (str): id do copiloto Retorna: None async def configurar(COM,device): s = serial.Serial(COM, 19200, timeout=10) try: for i in range(5): xvm = XVM.generateXVM(device,str(i).zfill(4),'>TCFG53,2<') print(xvm) s.write(xvm.encode()) resposta = s.readline().decode() print(resposta) if resposta: break except Exception as error: print('error', error) try: for i in range(5): xvm = XVM.generateXVM(device,str(i).zfill(4),'>VSIP0,TRM1<') print(xvm) s.write(xvm.encode()) resposta = s.readline().decode() print(resposta) if resposta: break except Exception as error: print('error', error) Coleta das mensagens e Insert no banco Fun\u00e7\u00e3o messages \u00e9 respons\u00e1vel por enviar um comando >QUV00rTRM< no formato XVM, quando o copiloto receber o comando ele inicia a descarga das mensagens do buffer GF0 O copiloto s\u00f3 entrega a proxima mensagem se receber o ACK de resposta, ACK \u00e9 gerado no formato XVM utilizando a fun\u00e7\u00e3o generateAck, que recebe o device_id e a sequence da mensagem A cada mensagem entregue do copiloto essa mensagem \u00e9 inserida na tabela coleta que cont\u00e9m o device_id, a mensagem entregue e a reception_datetime como colunas async def messages(COM,device): resposta = '' s = serial.Serial(COM, 19200,timeout=3) xvm = XVM.generateXVM(device,'8000','>QUV00rTRM<') s.write(xvm.encode()) while True: resposta = s.readline().decode() print(resposta) if resposta == '': print('acabou') break else: xvmMessage = XVM.parseXVM(resposta) msg = xvmMessage[0] device_id = xvmMessage[1] sequence = xvmMessage[2] print('msg:{}, device_id:{}, sequence:{}'.format(msg,device_id,sequence)) ack = XVM.generateAck(device_id,sequence) print(ack) s.write(ack.encode()) cursor.execute('INSERT INTO coleta (\"device_id\", \"message\") values (\\'{}\\', \\'{}\\');'.format(device_id, resposta)) connection.commit() A fun\u00e7\u00e3o message em partes Envia o comando para o copiloto descarregar as mensagens async def messages(COM,device): resposta = '' s = serial.Serial(COM, 19200,timeout=3) xvm = XVM.generateXVM(device,'8000','>QUV00rTRM<') s.write(xvm.encode()) Loop para coletar as mensagens at\u00e9 acabar while True: resposta = s.readline().decode() print(resposta) if resposta == '': print('acabou') break Faz o parser das mensagens para obter a sequence correta,utilizando a fun\u00e7\u00e3o parserXVM, e em seguida gera o ACK, utilizando a fun\u00e7\u00e3o generateAck else: xvmMessage = XVM.parseXVM(resposta) msg = xvmMessage[0] device_id = xvmMessage[1] sequence = xvmMessage[2] print('msg:{}, device_id:{}, sequence:{}'.format(msg,device_id,sequence)) ack = XVM.generateAck(device_id,sequence) print(ack) s.write(ack.encode()) Faz o insert no banco postgres cursor.execute('INSERT INTO coleta (\"device_id\", \"message\") values (\\'{}\\', \\'{}\\');'.format(device_id, resposta)) connection.commit() Main Fun\u00e7\u00e3o Main responsavel por chamar as outras fun\u00e7\u00f5es, utiliznado os argumentos necess\u00e1rios. async def main(): ports = serial.tools.list_ports.comports() for p in ports: print(p) print('estabelecendo conexao...') id = await asyncio.create_task(conexao(p.device)) await asyncio.create_task(configurar(p.device,id)) await asyncio.create_task(messages(p.device,id)) Botando para rodar if __name__ == '__main__': try: asyncio.run(main()) except KeyboardInterrupt: pass","title":"Descarga GFx"},{"location":"coleta/#descarga-gfx","text":"Arquivo coleta_GFx.py","title":"Descarga GFx"},{"location":"coleta/#conecta-ao-banco","text":"ENDPOINT=\"localhost\" PORT=\"5432\" USER=\"postgres\" DBNAME=\"inbox\" connection = psycopg2.connect(host=ENDPOINT, user=USER, password='postgres', port=PORT, database=DBNAME) cursor = connection.cursor()","title":"Conecta ao banco"},{"location":"coleta/#estabelecer-conexao-com-o-copiloto","text":"Fun\u00e7\u00e3o que estabelece uma conex\u00e3o serial com um dispositivo em uma porta COM e retorna seu ID. Envia QVR para a porta COM utilizando a fun\u00e7\u00e3o generateXVM que deixa o comando no formato em que o copiloto ir\u00e1 entender Argumentos: COM (str): A porta COM \u00e0 qual o dispositivo est\u00e1 conectado. Retorna: str: O ID do copiloto conectado. async def conexao(COM): s = serial.Serial(COM, 19200, timeout=10) id = '-' try: for i in range(5): xvm = XVM.generateXVM('1234',str(i).zfill(4),'>QVR<') print(xvm) s.write(xvm.encode()) resposta = s.readline().decode() id = resposta.split(';')[1][3::] if id != '1234': print(id) return id except Exception: print('PORTA SEM COMUNICA\u00c7\u00c3O') pass","title":"Estabelecer conex\u00e3o com o copiloto"},{"location":"coleta/#comandos-de-configuracao-do-copiloto","text":"Fun\u00e7\u00e3o que envia o comando >TCFG53,2< e >VSIP0,TRM1< para ativar a fun\u00e7\u00e3o de descarga do buffer GF0 pela serial \u00c9 necess\u00e1rio utilizar a fun\u00e7\u00e3o generateXVM para formatar os comandos no formato XVM Argumentos: COM (str): A porta COM \u00e0 qual o dispositivo est\u00e1 conectado. device (str): id do copiloto Retorna: None async def configurar(COM,device): s = serial.Serial(COM, 19200, timeout=10) try: for i in range(5): xvm = XVM.generateXVM(device,str(i).zfill(4),'>TCFG53,2<') print(xvm) s.write(xvm.encode()) resposta = s.readline().decode() print(resposta) if resposta: break except Exception as error: print('error', error) try: for i in range(5): xvm = XVM.generateXVM(device,str(i).zfill(4),'>VSIP0,TRM1<') print(xvm) s.write(xvm.encode()) resposta = s.readline().decode() print(resposta) if resposta: break except Exception as error: print('error', error)","title":"Comandos de configura\u00e7\u00e3o do copiloto"},{"location":"coleta/#coleta-das-mensagens-e-insert-no-banco","text":"Fun\u00e7\u00e3o messages \u00e9 respons\u00e1vel por enviar um comando >QUV00rTRM< no formato XVM, quando o copiloto receber o comando ele inicia a descarga das mensagens do buffer GF0 O copiloto s\u00f3 entrega a proxima mensagem se receber o ACK de resposta, ACK \u00e9 gerado no formato XVM utilizando a fun\u00e7\u00e3o generateAck, que recebe o device_id e a sequence da mensagem A cada mensagem entregue do copiloto essa mensagem \u00e9 inserida na tabela coleta que cont\u00e9m o device_id, a mensagem entregue e a reception_datetime como colunas async def messages(COM,device): resposta = '' s = serial.Serial(COM, 19200,timeout=3) xvm = XVM.generateXVM(device,'8000','>QUV00rTRM<') s.write(xvm.encode()) while True: resposta = s.readline().decode() print(resposta) if resposta == '': print('acabou') break else: xvmMessage = XVM.parseXVM(resposta) msg = xvmMessage[0] device_id = xvmMessage[1] sequence = xvmMessage[2] print('msg:{}, device_id:{}, sequence:{}'.format(msg,device_id,sequence)) ack = XVM.generateAck(device_id,sequence) print(ack) s.write(ack.encode()) cursor.execute('INSERT INTO coleta (\"device_id\", \"message\") values (\\'{}\\', \\'{}\\');'.format(device_id, resposta)) connection.commit()","title":"Coleta das mensagens e Insert no banco"},{"location":"coleta/#a-funcao-message-em-partes","text":"Envia o comando para o copiloto descarregar as mensagens async def messages(COM,device): resposta = '' s = serial.Serial(COM, 19200,timeout=3) xvm = XVM.generateXVM(device,'8000','>QUV00rTRM<') s.write(xvm.encode()) Loop para coletar as mensagens at\u00e9 acabar while True: resposta = s.readline().decode() print(resposta) if resposta == '': print('acabou') break Faz o parser das mensagens para obter a sequence correta,utilizando a fun\u00e7\u00e3o parserXVM, e em seguida gera o ACK, utilizando a fun\u00e7\u00e3o generateAck else: xvmMessage = XVM.parseXVM(resposta) msg = xvmMessage[0] device_id = xvmMessage[1] sequence = xvmMessage[2] print('msg:{}, device_id:{}, sequence:{}'.format(msg,device_id,sequence)) ack = XVM.generateAck(device_id,sequence) print(ack) s.write(ack.encode()) Faz o insert no banco postgres cursor.execute('INSERT INTO coleta (\"device_id\", \"message\") values (\\'{}\\', \\'{}\\');'.format(device_id, resposta)) connection.commit()","title":"A fun\u00e7\u00e3o message em partes"},{"location":"coleta/#main","text":"Fun\u00e7\u00e3o Main responsavel por chamar as outras fun\u00e7\u00f5es, utiliznado os argumentos necess\u00e1rios. async def main(): ports = serial.tools.list_ports.comports() for p in ports: print(p) print('estabelecendo conexao...') id = await asyncio.create_task(conexao(p.device)) await asyncio.create_task(configurar(p.device,id)) await asyncio.create_task(messages(p.device,id))","title":"Main"},{"location":"coleta/#botando-para-rodar","text":"if __name__ == '__main__': try: asyncio.run(main()) except KeyboardInterrupt: pass","title":"Botando para rodar"}]}